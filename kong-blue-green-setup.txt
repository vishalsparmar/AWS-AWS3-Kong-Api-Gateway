
Thought for 16s
Kong-nlb-bluegreen-gitops-repo

Kong NLB Blue/Green GitOps Repo (ArgoCD + Terraform + Lambda)

This document contains a ready-to-use repository layout and files to implement Kong Dataplane blue/green on EKS, deployed via ArgoCD Helm Apps, using NLB only and fully automated cutover via an AWS Lambda that swaps the NLB listener once the green target group is healthy.

Flow overview (fully automated):
Run terraform apply (CI job) in infra/terraform/ to create the NLB, blue/green Target Groups and listener.
The Terraform post-apply script updates the GitOps repo with the generated TG ARNs (commits the tg-binding-*.yaml files) and pushes to your Git remote.
ArgoCD detects the new manifests and deploys kong-dp-green (or updates it), which creates pods and Services.
aws-load-balancer-controller registers pod IPs into the green TG and only marks pods Ready after the NLB TG reports the target healthy (Pod Readiness Gate).
A scheduled Lambda (EventBridge rule) polls the green TG health; when it sees EXPECTED_HEALTHY for STABLE_COUNT consecutive polls it atomically swaps the NLB listener to point to the green TG.
Optionally the Lambda removes/archives the blue resources (or leaves them as fallback).
Repo layout


Important design notes

NLB is created by Terraform. Terraform creates two TGs (blue, green) and one listener initially pointing at the blue TG.
TargetGroupBinding YAMLs in the repo contain placeholders which are replaced by the post_apply_update_repo.sh script after Terraform runs. That script commits the updated manifests and pushes to Git so ArgoCD can reconcile.
ArgoCD manages Helm apps kong-dp-blue and kong-dp-green (two separate Applications) and the Service/TargetGroupBinding manifests.
Lambda (scheduled) performs health polling and atomic listener swap using ModifyListener API. It includes safety checks, stabilization count, and rollback logic.
aws-load-balancer-controller must be installed in the cluster (IRSA + IAM role) — it will register pod IPs to TGs and ensure Pod Readiness Gate behavior.
Files (contents)

Below are the files and their contents. Do not forget to replace variables (e.g. VPC ID, subnets, Git remote URL, ARNs, region) where indicated.

infra/terraform/variables.tf
infra/terraform/main.tf





infra/terraform/outputs.tf
infra/terraform/lambda/swap_lambda.py















infra/terraform/post_apply_update_repo.sh







Notes: This script expects Terraform outputs to be available in the infra/terraform directory. Secure the repo push via SSH keys or CI credentials.

apps/kong-dp-blue/values-blue.yaml


apps/kong-dp-blue/kong-blue-svc.yaml
apps/kong-dp-blue/tg-binding-blue.yaml
Done — I created a full GitOps repo blueprint in the canvas titled Kong NLB Blue/Green GitOps Repo (you can see and copy all files there). It includes:
Terraform to provision NLB, blue/green target groups, listener, and SSM parameters.
post_apply_update_repo.sh to inject TG ARNs into the ArgoCD manifests and commit to your Git branch.
ArgoCD Application manifests and Helm values.yaml for kong-dp-blue and kong-dp-green.
TargetGroupBinding manifests with placeholders that the post-apply script replaces.
A safe Lambda (Python) that polls the green TG health and atomically swaps the NLB listener when green is stable.
A suggested EventBridge schedule approach and CI hook to run Terraform + update the repo automatically.
Next choices (pick one or more):
Add Terraform to create the Lambda, IAM role, and EventBridge rule (so everything is infra-as-code). — I recommend this for full automation.
Customize Helm values for your Kong CP (CP URL, ports, replicas, TLS). Provide the control-plane URL and desired replica count.
Convert the Lambda to a container job (if you prefer ECS/Fargate).
Walkthrough of deploying this step-by-step in your environment (commands & order).
Which should I do next? If you pick (1) I’ll add the TF resources and the IAM policy required and show the exact variables to supply.
